<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ìŠ¤í† ë¦¬ ê²Œì„</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* ì»¤ìŠ¤í…€ ìŠ¤í¬ë¡¤ë°” */
        body::-webkit-scrollbar {
            width: 8px;
        }
        body::-webkit-scrollbar-thumb {
            background-color: #fca5a5; /* Red-400 */
            border-radius: 4px;
        }
        body::-webkit-scrollbar-track {
            background-color: #27272a; /* Zinc-800 */
        }
        /* ìŠ¤í† ë¦¬ í…ìŠ¤íŠ¸ ì• ë‹ˆë©”ì´ì…˜ */
        .story-text {
            white-space: pre-wrap;
            animation: typing 3s steps(40, end);
            overflow: hidden;
            border-right: .15em solid orange;
        }
        @keyframes typing {
            from { width: 0 }
            to { width: 100% }
        }
    </style>
</head>
<body class="bg-gray-900 text-white min-h-screen p-4">

    <div class="container mx-auto max-w-4xl">
        
        <div class="bg-gray-800 p-4 rounded-lg shadow-xl mb-6">
            <div id="status-user" class="text-lg font-semibold mb-2 text-yellow-400">í”Œë ˆì´ì–´: ë¡œë”© ì¤‘...</div>
            <div class="grid grid-cols-2 md:grid-cols-3 gap-2 text-sm font-medium">
                <div id="health" class="bg-red-600 p-2 rounded text-center">ì²´ë ¥: 100%</div>
                <div id="reputation" class="bg-green-600 p-2 rounded text-center">í‰íŒ: 50</div>
                <div id="morality" class="bg-blue-600 p-2 rounded text-center">ë„ë•ì„±: 50</div>
                <div id="danger-level" class="bg-orange-600 p-2 rounded text-center">ìœ„í—˜: 0</div>
                <div id="ptsd-level" class="bg-purple-600 p-2 rounded text-center">PTSD: 0</div>
            </div>
        </div>

        <div class="bg-gray-800 p-6 rounded-lg shadow-xl mb-6">
            
            <div id="scene-image-container" class="mb-6 relative">
                <div id="image-placeholder" class="flex items-center justify-center bg-zinc-700 h-96 rounded-lg text-lg text-gray-400">
                    ì´ë¯¸ì§€ ë¡œë”© ì¤‘ / ì—†ìŒ
                </div>
                <img id="scene-image" src="" alt="Scene Image" class="w-full h-96 object-cover rounded-lg shadow-md hidden">
            </div>

            <h1 id="scene-title" class="text-4xl font-bold mb-4 text-red-300">
                ì„œë²„ ì—°ê²° ì¤‘...
            </h1>
            <p id="scene-description" class="story-text text-gray-300">
                ì²« ë²ˆì§¸ ë”œë ˆë§ˆë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ì…ë‹ˆë‹¤. ì ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”.
            </p>

            <div id="error-message" class="hidden mt-4 p-3 bg-red-900 border border-red-500 rounded text-red-100">
                ì˜¤ë¥˜ ë‚´ìš©
            </div>

        </div>
        
        <div class="bg-gray-800 p-6 rounded-lg shadow-xl">
            <h2 class="text-2xl font-semibold mb-4 text-red-400">ì„ íƒ</h2>
            
            <div id="loading-indicator" class="text-center p-4">
                <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-red-500 mx-auto mb-2"></div>
                <p>ë°ì´í„° ë¡œë”© ì¤‘...</p>
            </div>

            <div id="choices-container" class="space-y-3">
                </div>
        </div>
    </div>

    <script>
        // Game state variables
        let currentState = {};
        let currentScene = {};

        // DOM element cache
        const sceneImageContainerEl = document.getElementById('scene-image-container');
        const sceneImageEl = document.getElementById('scene-image'); 
        const imagePlaceholderEl = document.getElementById('image-placeholder');
        const sceneTitleEl = document.getElementById('scene-title');
        const sceneDescriptionEl = document.getElementById('scene-description');
        const choicesContainerEl = document.getElementById('choices-container');
        const errorEl = document.getElementById('error-message');
        const statusUserEl = document.getElementById('status-user');
        const healthEl = document.getElementById('health');
        const reputationEl = document.getElementById('reputation');
        const moralityEl = document.getElementById('morality');
        const dangerLevelEl = document.getElementById('danger-level');
        const ptsdLevelEl = document.getElementById('ptsd-level');
        const loadingIndicatorEl = document.getElementById('loading-indicator');

        function setLoading(isLoading) {
            if (isLoading) {
                choicesContainerEl.innerHTML = '';
                loadingIndicatorEl.classList.remove('hidden');
            } else {
                loadingIndicatorEl.classList.add('hidden');
            }
        }

        // Function to update and display status
        function updateUI() {
            if (!currentScene.sceneId) {
                sceneTitleEl.textContent = 'ê²Œì„ ë¡œë”© ì‹¤íŒ¨';
                sceneDescriptionEl.textContent = 'ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì„œë²„ ìƒíƒœë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”.';
                return;
            }
            
            // 1. Update status display
            statusUserEl.textContent = `í”Œë ˆì´ì–´: ${currentState.username}`;
            healthEl.textContent = `ì²´ë ¥: ${currentState.health}%`;
            reputationEl.textContent = `í‰íŒ: ${currentState.reputation}`;
            moralityEl.textContent = `ë„ë•ì„±: ${currentState.morality}`;
            dangerLevelEl.textContent = `ìœ„í—˜: ${currentState.dangerLevel}`;
            ptsdLevelEl.textContent = `PTSD: ${currentState.PTSDLevel}`;
            
            // 2. Update scene text
            sceneTitleEl.textContent = currentScene.title;
            sceneDescriptionEl.textContent = currentScene.description;
            
            // 3. ğŸ–¼ï¸ ì´ë¯¸ì§€ ì²˜ë¦¬ ë¡œì§ (ì´ë¯¸ì§€ ê²½ë¡œ ìˆ˜ì • ë° ë¡œë”©)
            if (currentScene.imageUrl) {
                // ğŸ’¡ ìˆ˜ì •: imageUrlì—ì„œ íŒŒì¼ëª…ë§Œ ì¶”ì¶œí•˜ì—¬ '/images/' ê²½ë¡œë¥¼ ê°•ì œí•©ë‹ˆë‹¤.
                const filename = currentScene.imageUrl.split('/').pop();
                const correctImageUrl = `/images/${filename}`; 

                sceneImageEl.src = ''; 
                sceneImageEl.style.display = 'none'; 
                imagePlaceholderEl.textContent = 'ì´ë¯¸ì§€ ë¡œë”© ì¤‘...';
                imagePlaceholderEl.classList.remove('hidden');
                
                const newImage = new Image();
                newImage.onload = function() {
                    // ì„±ê³µ ì‹œ
                    sceneImageEl.src = correctImageUrl; // ìˆ˜ì •ëœ ê²½ë¡œ ì‚¬ìš©
                    sceneImageEl.style.display = 'block';
                    imagePlaceholderEl.classList.add('hidden');
                };
                newImage.onerror = function() {
                    // ì‹¤íŒ¨ ì‹œ
                    imagePlaceholderEl.textContent = `ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨: ${correctImageUrl} (ê²½ë¡œ ì˜¤ë¥˜ í™•ì¸)`;
                    imagePlaceholderEl.classList.remove('hidden');
                    sceneImageEl.style.display = 'none';
                };
                // ì‹¤ì œ ë¡œë”© ì‹œì‘
                newImage.src = correctImageUrl; // ìˆ˜ì •ëœ ê²½ë¡œ ì‚¬ìš©
            } else {
                // URLì´ ì—†ëŠ” ê²½ìš°
                sceneImageEl.style.display = 'none';
                imagePlaceholderEl.textContent = 'í˜„ì¬ ì¥ë©´ì— ì´ë¯¸ì§€ê°€ ì—†ìŠµë‹ˆë‹¤.';
                imagePlaceholderEl.classList.remove('hidden');
            }

            // 4. Create choice buttons
            choicesContainerEl.innerHTML = '';
            
            currentScene.choices.forEach((choice, index) => {
                const button = document.createElement('button');
                button.className = 'choice-button w-full text-left bg-red-600 hover:bg-red-700 text-white font-semibold py-3 px-4 rounded-lg shadow-md border-b-4 border-red-800';
                button.textContent = `${index + 1}. ${choice.choiceText}`;
                
                // Connect click event only if nextSceneId exists.
                if (choice.nextSceneId) {
                    button.onclick = () => moveScene(choice.nextSceneId); 
                }
                
                choicesContainerEl.appendChild(button);
            });
            
            setLoading(false);
        }

        // Common function to fetch game data from the server (with retry logic)
        async function fetchGameData(url, method = 'GET', body = null) {
            errorEl.classList.add('hidden');
            setLoading(true);

            const MAX_RETRIES = 3;
            for (let i = 0; i < MAX_RETRIES; i++) {
                try {
                    const options = {
                        method: method,
                        headers: { 'Content-Type': 'application/json' },
                    };
                    if (body) {
                        options.body = JSON.stringify(body);
                    }
                    
                    // âœ… ìˆ˜ì •: fetch ì£¼ì†ŒëŠ” Render ì„œë²„ì˜ ìƒëŒ€ ê²½ë¡œë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.
                    const response = await fetch(url, options); 
                    
                    // Handle errors if HTTP status code is 400 or higher
                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(`HTTP Error ${response.status}: ${errorText.substring(0, 100)}`);
                    }

                    const data = await response.json();
                    
                    if (data.success) {
                        currentState = data.userState;
                        currentScene = data.sceneData;
                        updateUI();
                        return true;
                    } else {
                        errorEl.textContent = `ê²Œì„ ì˜¤ë¥˜: ${data.message}`;
                        errorEl.classList.remove('hidden');
                        setLoading(false);
                        return false;
                    }

                } catch (error) {
                    if (i < MAX_RETRIES - 1) {
                        // Apply exponential backoff (1s, 2s, 4s)
                        await new Promise(resolve => setTimeout(resolve, 1000 * Math.pow(2, i)));
                    } else {
                        console.error("Fetch Error:", error);
                        errorEl.textContent = `ì„œë²„ ì—°ê²° ì‹¤íŒ¨! Render ì„œë²„ì— ë¬¸ì œê°€ ì—†ëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”. (ì˜¤ë¥˜: ${error.message})`;
                        errorEl.classList.remove('hidden');
                        setLoading(false);
                        return false;
                    }
                }
            }
        }

        // ğŸ’¡ ìˆ˜ì •ëœ loadGame í•¨ìˆ˜: DOM ì ‘ê·¼ ì˜¤ë¥˜ë¥¼ ë°©ì§€í•˜ê¸° ìœ„í•´ í…ìŠ¤íŠ¸ ì„¤ì • ë¶€ë¶„ì„ ì œê±°í–ˆìŠµë‹ˆë‹¤.
        async function loadGame() {
            // ì´ì œ H1ê³¼ P íƒœê·¸ì— ìˆëŠ” ì´ˆê¸° ë¡œë”© ë©”ì‹œì§€ê°€ ë¨¼ì € í‘œì‹œë˜ê³ ,
            // fetchGameDataê°€ ì„±ê³µí•˜ë©´ updateUIê°€ í˜¸ì¶œë˜ì–´ ì‹¤ì œ ë‚´ìš©ì„ í‘œì‹œí•©ë‹ˆë‹¤.
            await fetchGameData('/api/game/start'); 
        }

        // Scene transition function (called on button click)
        async function moveScene(nextSceneId) {
            const success = await fetchGameData(
                '/api/game/move', 
                'POST', 
                { 
                    nextSceneId: nextSceneId,
                    currentSceneId: currentScene.sceneId 
                }
            );
            
            if (success) {
                console.log(`Scene move successful: ${nextSceneId}`);
            }
        }

        // Start game on page load (DOMì´ ì™„ì „íˆ ë¡œë“œëœ í›„ loadGame í•¨ìˆ˜ ì‹¤í–‰)
        window.addEventListener('load', loadGame);
    </script>
</body>
</html>
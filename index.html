<script>
    // Game state variables
    let currentState = {};
    let currentScene = {};

    // DOM element cache
    const sceneImageContainerEl = document.getElementById('scene-image-container');
    const sceneImageEl = document.getElementById('scene-image'); 
    const imagePlaceholderEl = document.getElementById('image-placeholder');
    const sceneTitleEl = document.getElementById('scene-title');
    const sceneDescriptionEl = document.getElementById('scene-description');
    const choicesContainerEl = document.getElementById('choices-container');
    const errorEl = document.getElementById('error-message');
    const statusUserEl = document.getElementById('status-user');
    const healthEl = document.getElementById('health');
    const reputationEl = document.getElementById('reputation');
    const moralityEl = document.getElementById('morality');
    const dangerLevelEl = document.getElementById('danger-level');
    const ptsdLevelEl = document.getElementById('ptsd-level');
    const loadingIndicatorEl = document.getElementById('loading-indicator');

    function setLoading(isLoading) {
        if (isLoading) {
            choicesContainerEl.innerHTML = '';
            loadingIndicatorEl.classList.remove('hidden');
        } else {
            loadingIndicatorEl.classList.add('hidden');
        }
    }

    // Function to update and display status
    function updateUI() {
        if (!currentScene.sceneId) {
            sceneTitleEl.textContent = 'ê²Œì„ ë¡œë”© ì‹¤íŒ¨';
            sceneDescriptionEl.textContent = 'ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì„œë²„ ìƒíƒœë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”.';
            return;
        }
        
        // 1. Update status display
        statusUserEl.textContent = `í”Œë ˆì´ì–´: ${currentState.username}`;
        healthEl.textContent = `ì²´ë ¥: ${currentState.health}%`;
        reputationEl.textContent = `í‰íŒ: ${currentState.reputation}`;
        moralityEl.textContent = `ë„ë•ì„±: ${currentState.morality}`;
        dangerLevelEl.textContent = `ìœ„í—˜: ${currentState.dangerLevel}`;
        ptsdLevelEl.textContent = `PTSD: ${currentState.PTSDLevel}`;
        
        // 2. Update scene text
        sceneTitleEl.textContent = currentScene.title;
        sceneDescriptionEl.textContent = currentScene.description;
        
        // 3. ğŸ–¼ï¸ ì´ë¯¸ì§€ ì²˜ë¦¬ ë¡œì§ (ì´ë¯¸ì§€ ê²½ë¡œ ìˆ˜ì •)
        if (currentScene.imageUrl) {
            // ğŸ’¡ ìˆ˜ì •: imageUrlì—ì„œ íŒŒì¼ëª…ë§Œ ì¶”ì¶œí•˜ì—¬ '/images/' ê²½ë¡œë¥¼ ê°•ì œí•©ë‹ˆë‹¤.
            // ì´ë ‡ê²Œ í•´ì•¼ Render ì„œë²„ì˜ ì •ì  íŒŒì¼ ê²½ë¡œ ê·œì¹™ì„ ë”°ë¦…ë‹ˆë‹¤.
            const filename = currentScene.imageUrl.split('/').pop();
            const correctImageUrl = `/images/${filename}`; 

            sceneImageEl.src = ''; 
            sceneImageEl.style.display = 'none'; 
            imagePlaceholderEl.textContent = 'ì´ë¯¸ì§€ ë¡œë”© ì¤‘...';
            imagePlaceholderEl.classList.remove('hidden');
            
            const newImage = new Image();
            newImage.onload = function() {
                // ì„±ê³µ ì‹œ
                sceneImageEl.src = correctImageUrl; // ìˆ˜ì •ëœ ê²½ë¡œ ì‚¬ìš©
                sceneImageEl.style.display = 'block';
                imagePlaceholderEl.classList.add('hidden');
            };
            newImage.onerror = function() {
                // ì‹¤íŒ¨ ì‹œ
                imagePlaceholderEl.textContent = `ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨: ${correctImageUrl} (ê²½ë¡œ ì˜¤ë¥˜ í™•ì¸)`;
                imagePlaceholderEl.classList.remove('hidden');
                sceneImageEl.style.display = 'none';
            };
            // ì‹¤ì œ ë¡œë”© ì‹œì‘
            newImage.src = correctImageUrl; // ìˆ˜ì •ëœ ê²½ë¡œ ì‚¬ìš©
        } else {
            // URLì´ ì—†ëŠ” ê²½ìš°
            sceneImageEl.style.display = 'none';
            imagePlaceholderEl.textContent = 'í˜„ì¬ ì¥ë©´ì— ì´ë¯¸ì§€ê°€ ì—†ìŠµë‹ˆë‹¤.';
            imagePlaceholderEl.classList.remove('hidden');
        }

        // 4. Create choice buttons
        choicesContainerEl.innerHTML = '';
        
        currentScene.choices.forEach((choice, index) => {
            const button = document.createElement('button');
            button.className = 'choice-button w-full text-left bg-red-600 hover:bg-red-700 text-white font-semibold py-3 px-4 rounded-lg shadow-md border-b-4 border-red-800';
            button.textContent = `${index + 1}. ${choice.choiceText}`;
            
            // Connect click event only if nextSceneId exists.
            if (choice.nextSceneId) {
                button.onclick = () => moveScene(choice.nextSceneId); 
            }
            
            choicesContainerEl.appendChild(button);
        });
        
        setLoading(false);
    }

    // Common function to fetch game data from the server (with retry logic)
    async function fetchGameData(url, method = 'GET', body = null) {
        errorEl.classList.add('hidden');
        setLoading(true);

        const MAX_RETRIES = 3;
        for (let i = 0; i < MAX_RETRIES; i++) {
            try {
                const options = {
                    method: method,
                    headers: { 'Content-Type': 'application/json' },
                };
                if (body) {
                    options.body = JSON.stringify(body);
                }
                
                // âœ… ìˆ˜ì •: fetch ì£¼ì†ŒëŠ” Render ì„œë²„ì˜ ìƒëŒ€ ê²½ë¡œë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.
                const response = await fetch(url, options); 
                
                // Handle errors if HTTP status code is 400 or higher
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`HTTP Error ${response.status}: ${errorText.substring(0, 100)}`);
                }

                const data = await response.json();
                
                if (data.success) {
                    currentState = data.userState;
                    currentScene = data.sceneData;
                    updateUI();
                    return true;
                } else {
                    errorEl.textContent = `ê²Œì„ ì˜¤ë¥˜: ${data.message}`;
                    errorEl.classList.remove('hidden');
                    setLoading(false);
                    return false;
                }

            } catch (error) {
                if (i < MAX_RETRIES - 1) {
                    // Apply exponential backoff (1s, 2s, 4s)
                    await new Promise(resolve => setTimeout(resolve, 1000 * Math.pow(2, i)));
                } else {
                    console.error("Fetch Error:", error);
                    errorEl.textContent = `ì„œë²„ ì—°ê²° ì‹¤íŒ¨! Render ì„œë²„ì— ë¬¸ì œê°€ ì—†ëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”. (ì˜¤ë¥˜: ${error.message})`;
                    errorEl.classList.remove('hidden');
                    setLoading(false);
                    return false;
                }
            }
        }
    }


    // Game start function (initial load)
    async function loadGame() {
        // H1ê³¼ P íƒœê·¸ì— ì´ˆê¸° ë¡œë”© ë©”ì‹œì§€ê°€ ìˆìœ¼ë¯€ë¡œ, UI ì—…ë°ì´íŠ¸ ì—†ì´ ë°”ë¡œ ìš”ì²­ì„ ë³´ëƒ…ë‹ˆë‹¤.
        // âœ… ìˆ˜ì •: ë¡œì»¬ ì£¼ì†Œ 'http://localhost:8080' ì‚­ì œí•˜ê³  ìƒëŒ€ ê²½ë¡œë¡œ ë³€ê²½!
        await fetchGameData('/api/game/start'); 
    }

    // Scene transition function (called on button click)
    async function moveScene(nextSceneId) {
        const success = await fetchGameData(
            // âœ… ìˆ˜ì •: ë¡œì»¬ ì£¼ì†Œ 'http://localhost:8080' ì‚­ì œí•˜ê³  ìƒëŒ€ ê²½ë¡œë¡œ ë³€ê²½!
            '/api/game/move', 
            'POST', 
            { 
                nextSceneId: nextSceneId,
                currentSceneId: currentScene.sceneId 
            }
        );
        
        if (success) {
            console.log(`Scene move successful: ${nextSceneId}`);
        }
    }

    // Start game on page load
    window.addEventListener('load', loadGame);
</script>
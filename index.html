<script>
    // Game state variables
    let currentState = {};
    let currentScene = {};

    // DOM element cache
    const sceneImageContainerEl = document.getElementById('scene-image-container');
    const sceneImageEl = document.getElementById('scene-image'); 
    const imagePlaceholderEl = document.getElementById('image-placeholder');
    const sceneTitleEl = document.getElementById('scene-title');
    const sceneDescriptionEl = document.getElementById('scene-description');
    const choicesContainerEl = document.getElementById('choices-container');
    const errorEl = document.getElementById('error-message');
    const statusUserEl = document.getElementById('status-user');
    const healthEl = document.getElementById('health');
    const reputationEl = document.getElementById('reputation');
    const moralityEl = document.getElementById('morality');
    const dangerLevelEl = document.getElementById('danger-level');
    const ptsdLevelEl = document.getElementById('ptsd-level');
    const loadingIndicatorEl = document.getElementById('loading-indicator');

    function setLoading(isLoading) {
        if (isLoading) {
            choicesContainerEl.innerHTML = '';
            loadingIndicatorEl.classList.remove('hidden');
        } else {
            loadingIndicatorEl.classList.add('hidden');
        }
    }

    // Function to update and display status
    function updateUI() {
        if (!currentScene.sceneId) {
            sceneTitleEl.textContent = 'ê²Œì„ ë¡œë”© ì‹¤íŒ¨';
            sceneDescriptionEl.textContent = 'ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì„œë²„ ìƒíƒœë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”.';
            return;
        }
        
        // 1. Update status display
        statusUserEl.textContent = `í”Œë ˆì´ì–´: ${currentState.username}`;
        healthEl.textContent = `ì²´ë ¥: ${currentState.health}%`;
        reputationEl.textContent = `í‰íŒ: ${currentState.reputation}`;
        moralityEl.textContent = `ë„ë•ì„±: ${currentState.morality}`;
        dangerLevelEl.textContent = `ìœ„í—˜: ${currentState.dangerLevel}`;
        ptsdLevelEl.textContent = `PTSD: ${currentState.PTSDLevel}`;
        
        // 2. Update scene text
        sceneTitleEl.textContent = currentScene.title;
        sceneDescriptionEl.textContent = currentScene.description;
        
        // 3. ğŸ–¼ï¸ ì´ë¯¸ì§€ ì²˜ë¦¬ ë¡œì§ (ê°€ì¥ ë‹¨ìˆœí•˜ê³  ì•ˆì •ì ì¸ ë¡œì§)
        if (currentScene.imageUrl) {
            sceneImageEl.src = ''; // ì´ì „ ì´ë¯¸ì§€ ì†ŒìŠ¤ ì´ˆê¸°í™”
            sceneImageEl.style.display = 'none'; // ì´ë¯¸ì§€ íƒœê·¸ ìˆ¨ê¸°ê¸°
            imagePlaceholderEl.textContent = 'ì´ë¯¸ì§€ ë¡œë”© ì¤‘...';
            imagePlaceholderEl.classList.remove('hidden');
            
            // ì´ë¯¸ì§€ ë¡œë”©ì„ ì‹œë„í•©ë‹ˆë‹¤.
            const newImage = new Image();
            newImage.onload = function() {
                // ì„±ê³µ ì‹œ: í”Œë ˆì´ìŠ¤í™€ë” ìˆ¨ê¸°ê³ , ì´ë¯¸ì§€ íƒœê·¸ì— ì†ŒìŠ¤ë¥¼ ì„¤ì •í•˜ì—¬ í‘œì‹œ
                sceneImageEl.src = currentScene.imageUrl;
                sceneImageEl.style.display = 'block';
                imagePlaceholderEl.classList.add('hidden');
            };
            newImage.onerror = function() {
                // ì‹¤íŒ¨ ì‹œ: í”Œë ˆì´ìŠ¤í™€ë”ì— ì˜¤ë¥˜ ë©”ì‹œì§€ í‘œì‹œ
                imagePlaceholderEl.textContent = 'ì´ë¯¸ì§€ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. (URL ì˜¤ë¥˜ í™•ì¸)';
                imagePlaceholderEl.classList.remove('hidden');
                sceneImageEl.style.display = 'none';
            };
            // ì‹¤ì œ ë¡œë”© ì‹œì‘
            newImage.src = currentScene.imageUrl; 
        } else {
            // URLì´ ì—†ëŠ” ê²½ìš°: ì´ë¯¸ì§€ ìˆ¨ê¸°ê³  í”Œë ˆì´ìŠ¤í™€ë” í‘œì‹œ
            sceneImageEl.style.display = 'none';
            imagePlaceholderEl.textContent = 'í˜„ì¬ ì¥ë©´ì— ì´ë¯¸ì§€ê°€ ì—†ìŠµë‹ˆë‹¤.';
            imagePlaceholderEl.classList.remove('hidden');
        }

        // 4. Create choice buttons
        choicesContainerEl.innerHTML = '';
        
        currentScene.choices.forEach((choice, index) => {
            const button = document.createElement('button');
            button.className = 'choice-button w-full text-left bg-red-600 hover:bg-red-700 text-white font-semibold py-3 px-4 rounded-lg shadow-md border-b-4 border-red-800';
            button.textContent = `${index + 1}. ${choice.choiceText}`;
            
            // Connect click event only if nextSceneId exists.
            if (choice.nextSceneId) {
                button.onclick = () => moveScene(choice.nextSceneId); 
            }
            
            choicesContainerEl.appendChild(button);
        });
        
        setLoading(false);
    }

    // Common function to fetch game data from the server (with retry logic)
    async function fetchGameData(url, method = 'GET', body = null) {
        errorEl.classList.add('hidden');
        setLoading(true);

        const MAX_RETRIES = 3;
        for (let i = 0; i < MAX_RETRIES; i++) {
            try {
                const options = {
                    method: method,
                    headers: { 'Content-Type': 'application/json' },
                };
                if (body) {
                    options.body = JSON.stringify(body);
                }
                
                const response = await fetch(url, options);
                
                // Handle errors if HTTP status code is 400 or higher
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`HTTP Error ${response.status}: ${errorText.substring(0, 100)}`);
                }

                const data = await response.json();
                
                if (data.success) {
                    currentState = data.userState;
                    currentScene = data.sceneData;
                    updateUI();
                    return true;
                } else {
                    errorEl.textContent = `ê²Œì„ ì˜¤ë¥˜: ${data.message}`;
                    errorEl.classList.remove('hidden');
                    setLoading(false);
                    return false;
                }

            } catch (error) {
                if (i < MAX_RETRIES - 1) {
                    // Apply exponential backoff (1s, 2s, 4s)
                    await new Promise(resolve => setTimeout(resolve, 1000 * Math.pow(2, i)));
                } else {
                    console.error("Fetch Error:", error);
                    // ğŸš¨ ì´ ì˜¤ë¥˜ ë©”ì‹œì§€ëŠ” ë¡œì»¬ í™˜ê²½ì—ì„œë§Œ ëœ¨ë„ë¡ ìˆ˜ì •
                    errorEl.textContent = `ì„œë²„ ì—°ê²° ì‹¤íŒ¨! (ì˜¤ë¥˜: ${error.message})`; 
                    errorEl.classList.remove('hidden');
                    setLoading(false);
                    return false;
                }
            }
        }
    }


    // Game start function (initial load)
    async function loadGame() {
        sceneTitleEl.textContent = 'ì„œë²„ ì—°ê²° ì¤‘...';
        sceneDescriptionEl.textContent = 'ì²« ë²ˆì§¸ ë”œë ˆë§ˆë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ì…ë‹ˆë‹¤. ì ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”.';
        // âœ… ìˆ˜ì •: ë¡œì»¬ ì£¼ì†Œ 'http://localhost:8080' ì‚­ì œí•˜ê³  ìƒëŒ€ ê²½ë¡œë¡œ ë³€ê²½!
        await fetchGameData('/api/game/start'); 
    }

    // Scene transition function (called on button click)
    async function moveScene(nextSceneId) {
        const success = await fetchGameData(
            // âœ… ìˆ˜ì •: ë¡œì»¬ ì£¼ì†Œ 'http://localhost:8080' ì‚­ì œí•˜ê³  ìƒëŒ€ ê²½ë¡œë¡œ ë³€ê²½!
            '/api/game/move', 
            'POST', 
            { 
                nextSceneId: nextSceneId,
                currentSceneId: currentScene.sceneId 
            }
        );
        
        if (success) {
            console.log(`Scene move successful: ${nextSceneId}`);
        }
    }

    // Start game on page load
    window.addEventListener('load', loadGame);
</script>